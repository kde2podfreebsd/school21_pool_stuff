# *Unix comand line interface
![enter image description here](https://habrastorage.org/r/w1560/getpro/habr/upload_files/888/cc1/234/888cc1234f2dcb94071a73cd7426c2fd.png)

#### По факту этот .md - это конспект курса https://ru.hexlet.io/courses/cli-basics - приоритеней пройти его.

## Историческая справка 
-   Unix - многопользовательская операционная система для мейнфреймов.
-   Unix позволяла подключаться через терминалы для ввода и вывода информации.
-   Стандарт POSIX был создан для обеспечения совместимости операционных систем.
-   Linux разработан Линусом Торвальдсом, совместим с POSIX и популярен на серверах.
-   Linux включает в себя GNU-программы и может иметь разные графические оболочки.
-   Дистрибутивы Linux включают в себя саму ОС, GNU-программы и утилиты для установки и настройки.
-   Ubuntu - популярный бесплатный дистрибутив Linux.
-   Windows не совместима с POSIX и редко используется на серверах.
-   macOS является POSIX-совместимой операционной системой.
-   В курсе будут рассматриваться примеры работы с командной строкой на POSIX-совместимых ОС.

## Shell и Terminal
-   Терминал - программа, эмулирующая поведение hard(железного) терминала и дающая доступ к оболочке.
-   Терминалы могут иметь вкладки и сплиты для удобства.
-   Командная оболочка - программа для управления ОС и программами через командную строку.
-   Оболочка позволяет выполнять команды и имеет полноценные средства программирования. (примеры оболочек: bash, zsh, fish)
-   Командная оболочка и терминал - не одно и то же. Терминал запускает командную оболочку.
-   Взаимодействие с командной оболочкой происходит в режиме REPL: чтение, выполнение, вывод, цикл.
![enter image description here](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImU0NWM5MzAyNzc3YzFmYWI4NTRmYjJhOTBlOGYyYmRhLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=9d7403035abb1815905f3ed74c80704f24e1b8adbb862c92c808b46dc4181fb2)
## **Навигация в командной строке - Основы командной строки**
При работе с командной строкой, для начала, нам нужно знать, как перемещаться по файловой системе. 

**Определение Текущей Директории**

Когда мы начинаем сессию в командной оболочке, мы находимся в какой-то директории, называемой "рабочей директорией" (working directory). Мы можем узнать, в какой директории мы находимся, с помощью команды `pwd` (сокращение от "print working directory"):
Эта команда выведет текущий путь к рабочей директории, например:
```bash
pwd
/Users/guest
``` 
Заметим, что первый символ пути `/` указывает на корневую директорию, от которой начинается файловая система.

**Просмотр Содержимого Директории**

Для просмотра файлов и поддиректорий в текущей директории используется команда `ls` (сокращение от "list"):
Эта команда выведет список файлов и директорий в текущей рабочей директории:
```bash
ls
Desktop  Documents  Downloads  Library  Movies  Music  Pictures  Public
``` 

**Перемещение между Директориями**

Для перемещения в другую директорию мы используем команду `cd` (сокращение от "change directory"). Чтобы перейти в другую директорию, необходимо передать аргумент - имя директории:

bash

```bash 
cd Music
``` 

Это переместит нас в директорию `Music`. Мы также можем вернуться обратно в предыдущую директорию, используя две точки `..`:
```bash
cd ..
``` 

Это переместит нас на уровень выше в файловой структуре. Для перехода к домашней директории текущего пользователя можно использовать команду `cd` без аргументов:

```bash
cd
``` 

Альтернативно, можно использовать тильду `~`, чтобы перейти в домашнюю директорию:
```bash
cd ~
``` 

**Автокомплит и Заполнители Путей**

Чтобы сделать навигацию более удобной, командная строка предоставляет функцию автокомплита, которая позволяет автоматически завершать имена файлов и директорий. Для использования автокомплита, можно дважды нажать клавишу `Tab`, и командная строка автоматически завершит имя файла или директории.

Например, если у нас есть директория `My Documents`, то можно начать вводить `cd My` и затем нажать `Tab`, чтобы командная строка автоматически завершила имя:
bash

```bash
cd My\ Documents
``` 
Это сделает навигацию более быстрой и предотвратит ошибки при вводе путей.

## Аргументы и опции

-   В CLI вы взаимодействуете с программами, вводя их название и передавая им аргументы и опции.
-   Например, для списка файлов и директорий, используйте команду `ls`.
-   Пример простой команды: `ls`.

### Аргументы

-   Аргументы - это значения или параметры, передаваемые программе.
-   Например, `ls Music` - здесь `Music` является аргументом, который указывает программе `ls` на каталог, который нужно показать.

### Опции
В командной строке можно использовать опции (или флаги) для настройки поведения программ. Опции бывают короткими (с одним дефисом) и длинными (с двумя дефисами). Использование коротких и длинных опций зависит от контекста:
	
-   Опции (иногда называют флагами) позволяют настраивать поведение команды.
-   Опции всегда начинаются с одного или двух дефисов (например, `-a` или `--all`).
-   Пример: `ls -a` - эта команда с опцией `-a` отображает скрытые файлы и директории.
    
Опции могут принимать параметры. Параметры указываются после опции, разделяются пробелом и могут быть обернуты в кавычки. Например:

 ```bash
say -o hi.aac 'Hello, World.'
```
 - опция `-o` с параметром `'hi.aac'`.

```bash
say -o=hi.aac 'Hello, World.'
``` 
- использование знака `=` вместо пробела для указания параметра.

Некоторые программы могут иметь более сложные опции, которые предоставляют дополнительную функциональность. Например, команда `say` в macOS имеет опцию `-o`, которая позволяет указать путь до файла для записи произнесенного текста.

В документации каждой программы обычно есть раздел SYNOPSIS, где перечислены все доступные опции и их параметры. Пример описания:

less

```bash
say [-v voice] [-r rate] [-o outfile [audio format options] | -n name:port | -a device] [-f file | string ...]
``` 

-   Квадратные скобки `[]` обозначают необязательность опции или параметра.
-   Вертикальная черта `|` обозначает операцию "или", указывая альтернативные варианты использования опций.

## Файловая структура в *nix-системах

В *nix-системах (Linux и Unix) файловая структура имеет некоторые особенности, отличающиеся от структуры в Windows.
![Файловая структура в *nix-системах](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjMxOTIxYmZmMzRlMjE4NDVhMTAwYTU1Y2JkZTYyMzBkLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=53585937c4158b0adaae1cba4603e2bd6bff72f73ba200e938e9647ee6ec1920)
1.  **Дерево файловой структуры:**
    
    -   В *nix-системах файловая структура представляет собой дерево с корнем в `/`.
    -   Все устройства и диски, физические и логические, находятся внутри этого дерева в виде директорий и файлов.
2.  **Директории:**
    
    -   Вместо термина "папка", в *nix-системах используют термины "директория" или "каталог".
    -   Директории - это файлы специального типа, которые содержат список других файлов и директорий.
3.  **Регистр имеет значение:**
    
    -   В отличие от Windows, в *nix-системах регистр символов имеет значение. Это значит, что файлы с разным регистром в имени считаются разными файлами.
    -   Например, `index.html` и `Index.html` - это разные файлы.
4.  **FHS (Filesystem Hierarchy Standard):**
    
    -   В *nix-системах существует стандартная файловая структура, называемая FHS. Она определяет предназначение различных каталогов в системе.
    -   Например, `/etc` содержит конфигурационные файлы программ, а `/home` - домашние директории пользователей (за исключением суперпользователя root).
5.  **Скрытые файлы:**
    
    -   В *nix-системах скрытые файлы начинаются с точки в имени файла. Например, `.bashrc`.
    -   Скрытые файлы можно отобразить с помощью команды `ls -a`.
6.  **Специальные типы файлов:**
    
    -   В *nix-системах существуют специальные типы файлов, такие как Hard Link (жесткая ссылка), Symbolic Link (символическая ссылка) и Socket (сокет).
    -   Жесткая ссылка - это дополнительное имя для уже существующего файла.
    -   Символическая ссылка похожа на ярлык в Windows.
    -   Сокеты используются для взаимодействия между разными процессами в операционной системе.

Файловая структура в *nix-системах предоставляет много гибкости и контроля, особенно с точки зрения прав доступа и управления файлами.

## Чтение файлов в командной строке в *nix-системах

В *nix-системах, чтение текстовых файлов в командной строке может быть выполнено различными командами. Рассмотрим несколько основных команд:

 - cat
 - head
 - tail
 - less

### 1. `cat` - Конкатенация и вывод файлов

Команда `cat` (от "concatenate") используется для объединения и вывода содержимого файлов. Просто укажите путь к файлу, и его содержимое будет выведено в командной строке:

```bash
cat filename
``` 

### 2. `head` и `tail` - Первые и последние строки файла

Команды `head` и `tail` используются для отображения первых и последних строк файла соответственно. По умолчанию, они выводят первые или последние 10 строк файла, но вы можете указать другое количество строк с помощью опции `-n`:
```bash
head -n 5 filename  # Показать первые 5 строк файла
tail -n 15 filename # Показать последние 15 строк файла
``` 

### 3. `tail -f` - Отслеживание логов в реальном времени

Команда `tail -f` используется для отслеживания содержимого файла в реальном времени. Она выводит последние строки файла и автоматически обновляет вывод, когда в файл добавляются новые строки. Это полезно при мониторинге логов и журналов системы.
```bash
tail -f filename
``` 

### 4. Пейджеры (`less`)

Пейджеры, такие как `less`, предоставляют более интерактивный способ просмотра файлов. Они позволяют перемещаться по содержимому файла, выполнять поиск и многое другое. Для открытия файла в `less`, просто укажите его имя:

```bash
less filename
``` 
В `less` можно использовать следующие команды:

-   `q` - выход из пейджера.
-   `space` - перейти к следующей странице.
-   `b` - вернуться к предыдущей странице.
-   `/` - начать поиск. После `/` введите текст для поиска, затем нажмите `Enter`. Для перехода к следующему совпадению используйте `n`.


## Grep
Команда `grep` является мощным инструментом для поиска текстовых данных в файлах и директориях в *nix-системах. Рассмотрим основные опции и примеры использования команды `grep`:
### Основное использование `grep`:

bash

```bash
grep PATTERN FILE...
``` 

-   `PATTERN` - это строка или регулярное выражение, которое вы ищете в файлах.
-   `FILE...` - это список файлов, в которых нужно искать.

### Примеры использования `grep`:

1.  Простой поиск строки в файле:

bash

```
grep "search_string" filename
``` 

2.  Поиск с отображением контекста:

Используйте опции `-B`, `-A`, или `-C`, чтобы отобразить строки перед (`-B`), после (`-A`), или и перед, и после (`-C`) найденной строки.

```bash
grep -C 1 "search_string" filename
``` 

3.  Рекурсивный поиск в директории:

Используйте опцию `-r`, чтобы выполнять поиск в директории и ее поддиректориях.

```bash
grep -r "search_string" directory_path
``` 

4.  Поиск с номерами строк:

Используйте опцию `-n`, чтобы выводить номера строк, в которых найдено совпадение.
```bash
grep -n "search_string" filename
``` 

## Редактирование файлов (nano)
### !!! Vim будет рассмотрен в отдельной статье
Редактор Nano - это простой и легкий текстовый редактор, который часто используется для быстрого редактирования файлов в командной строке. Вот несколько основных команд для работы с Nano:

 **Открыть файл**: Для открытия файла в Nano, просто введите `nano` и путь к файлу:
    
   ```bash
   nano filename
   ``` 
    
-   **Сохранить файл**: Чтобы сохранить изменения в файле, нажмите `Ctrl + O`, затем подтвердите, нажав Enter.
    
-   **Закрыть файл**: Для закрытия файла в Nano, нажмите `Ctrl + X`. Если внесены изменения, Nano запросит вас сохранить их.
    
-   **Перемещение по тексту**: Вы можете использовать клавиши стрелок для перемещения по тексту. Чтобы прокрутить большие файлы, можно использовать клавиши `Ctrl + Y` (вверх) и `Ctrl + V` (вниз).
    
-   **Вырезать, копировать и вставить**: Для вырезания текста используйте `Ctrl + K`, для копирования - `Ctrl + ^`, а для вставки - `Ctrl + U`.
    
-   **Поиск и замена**: Для поиска текста в Nano используйте `Ctrl + W`, а для поиска и замены - `Ctrl + \`. Следуйте инструкциям внизу экрана для поиска и подтверждения замены.
    
-   **Отмена действия**: Чтобы отменить предыдущее действие, нажмите `Ctrl + _`.
    
-   **Справка**: Для получения справки о доступных командах в Nano нажмите `Ctrl + G`.
    
-   **Выход без сохранения**: Если вы хотите выйти из Nano без сохранения изменений, просто нажмите `Ctrl + X` и затем `N` при запросе сохранения.
    
-   **Отключение автоматической переноски строк**: Если вы хотите отключить автоматическую переноску строк, используйте `Alt + L` (это буква "L", а не цифра "1").


## Streams |  Потоки
В операционной системе все программы работают с тремя потоками:

-   STDIN (Standard Input)
-   STDOUT (Standard Output)
-   STDERR (Standard Error)

Языки программирования взаимодействуют с этими потоками как с файлами.

Поток STDOUT отвечает за вывод на экран:

-   Функция печати записывает данные в поток STDOUT с помощью функции write.
-   Операционная система решает, куда вывести результат, по умолчанию на экран терминала.

Операционная система управляет взаимодействием с железом, а не языки программирования.

Потоки позволяют написать программу на одном компьютере и запустить ее на другом без проблем.

Перенаправление потоков позволяет изменять направление вывода команд, например, выводить результаты в файл:

-   `ls -la > output` записывает вывод команды `ls -la` в файл `output`.
-   `grep alias .bash_profile > result` записывает вывод команды `grep alias .bash_profile` в файл `result`.

Для добавления в файл используется `>>`:

-   `echo 'hello' >> result` добавляет строку в конец файла `result`.

Помимо STDOUT, есть два дополнительных потока: STDERR и STDIN.

-   STDERR выводит ошибки.
-   STDIN позволяет программе получать данные на вход.

Перенаправление ввода и вывода:

-   `wc -l < result` отправляет содержимое файла `result` в стандартный ввод команды `wc`.
-   `wc -l < result > output` отправляет содержимое файла `result` в стандартный ввод команды `wc` и выводит результат в файл `output`.

![enter image description here](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjE1NDk4YzkxNmQyZjQ4YjIzNTBlOTE2MjFkM2IxMjdmLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=f4621a09cd58fa2a5c4134bcc4b1f6daf1ad40fd2c1a17095d5a2901f142d009)

Поток STDERR позволяет отделять нормальный вывод программы от ошибок и удобен при ведении логов и отладке.

По умолчанию, как и STDOUT, STDERR выводит информацию на экран.

Перенаправление вывода в файл работает только для STDOUT, и STDERR остается привязанным к экрану.

Для объединения вывода ошибок и нормального вывода:

-   Используют файловые дескрипторы, где STDERR — 2, и можно перенаправить STDERR в STDOUT: `ls lala > output 2>&1`

Важно использовать символ `&` после `2`, чтобы указать поток, который перенаправляется.

Если порядок перенаправления нарушен, потоки не объединяются, например: `ls lala 2>&1 > output` не работает.

Перенаправление STDERR в файл без вывода в STDOUT: `cd lala 2> output`

Перенаправление обоих потоков в файл: `cd lala &> output`


## Pipeline | Пайплайн
Пайплайн (pipeline) в командной строке позволяет соединять программы и передавать данные между ними, создавая цепочку функций, где каждое звено выполняет преобразование или фильтрацию.

Пайплайны позволяют легко комбинировать утилиты без необходимости изменения самих программ.

Пример использования пайплайна:
```bash
grep alias .bashrc | grep color
``` 

Этот пайплайн берет вывод первой команды (grep alias .bashrc) и передает его как входные данные во вторую команду (grep color).

Символ | обозначает пайп, указывая на соединение потока STDOUT одного процесса с потоком STDIN другого.
![enter image description here](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjQyN2E1ZjRjZTg2MmVkM2Q4YWM1MGU0OTdjMzI1NjI3LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=7e08db259cf98088ecd9ceccdd98e76400f8c78b49aca21a2cfa35b8271cd3db)

Пайплайны могут быть бесконечно комбинированы, так что утилиты, работающие с текстовыми данными, могут быть эффективно сопряжены.

Пайплайны основаны на философии Unix:

-   Написание программ, которые выполняют одну задачу хорошо.
-   Создание программ, которые могут взаимодействовать друг с другом.
-   Поддержка текстовых потоков как универсального интерфейса.

Пайплайны позволяют создавать сложное поведение из простых составных блоков, подобно конструкторам Lego.

## Манипуляция файловой структурой 
В командной строке можно создавать, удалять, перемещать и копировать файлы и директории.

- Создание файла с помощью `touch`:
    
 ```bash
  touch empty-file
``` 
    
-   Удаление файла с помощью `rm`:
```bash
rm empty-file
``` 
    
-   Переименование файла с помощью `mv`:
```bash
mv file renamed-file
``` 
    
-   Копирование файла с помощью `cp`:
   ```bash
   cp renamed-file renamed-file-copy
   ```
    
-   Копирование директории (рекурсивно) с флагом `-r`:
```bash
cp -r source-dir destination-dir
``` 
    
-   Создание директории с помощью `mkdir`:
```bash
mkdir my-dir
``` 
    
-   Создание директории и её вложенных поддиректорий с флагом `-p`:
```bash
mkdir -p one/two/three
``` 
    
-   Удаление директории с её содержимым (рекурсивно) с флагом `-r`:
```bash
rm -r my-dir
``` 
    
-   Удаление директории без подтверждения и игнорирования ошибок с флагами `-rf`:
```bash
rm -rf one
```

При выполнении операций важно учесть права пользователя.

## Переменные окружения 
Переменные окружения в командной строке аналогичны переменным в языках программирования, но они существуют только в рамках текущей сессии командного интерпретатора и могут быть установлены как локально, так и глобально.

Для просмотра всех переменных окружения, доступных в текущей сессии, можно использовать команду `env`:
```bash
env
SYSTEMD_EXEC_PID=2149
SSH_AUTH_SOCK=/run/user/1000/keyring/ssh
SESSION_MANAGER=local/localhost:@/tmp/.ICE-unix/2114,unix/localhost:/tmp/.ICE-unix/2114
GNOME_TERMINAL_SCREEN=/org/gnome/Terminal/screen/a5a36e3b_5f56_4b02_af12_fd8e3cf3f54f
LANG=en_US.UTF-8
XDG_CURRENT_DESKTOP=GNOME
LC_ADDRESS=en_US.UTF-8
WAYLAND_DISPLAY=wayland-0
LC_IDENTIFICATION=en_US.UTF-8
XDG_SESSION_CLASS=user
QT_QPA_PLATFORMTHEME=qt5ct
COLORTERM=truecolor
QT_IM_MODULE=ibus
LC_MEASUREMENT=en_US.UTF-8
USER=donqhomo
XDG_MENU_PREFIX=gnome-
OLDPWD=/home/donqhomo
PWD=/home/donqhomo
PT8HOME=/opt/packettracer/
DOTNET_BUNDLE_EXTRACT_BASE_DIR=/home/donqhomo/.cache/dotnet_bundle_extract
DISPLAY=:0
DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus
LC_NUMERIC=en_US.UTF-8
XDG_DATA_DIRS=/home/donqhomo/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop
VTE_VERSION=7202
XDG_SESSION_DESKTOP=gnome
DESKTOP_SESSION=gnome
GNOME_SETUP_DISPLAY=:1
LC_TIME=en_US.UTF-8
MAIL=/var/spool/mail/donqhomo
DEBUGINFOD_URLS=https://debuginfod.archlinux.org 
...
``` 

Формат вывода команды `env`: имя переменной, знак равно и значение переменной.

Основное назначение переменных окружения - настройка системы и программ. Например, команда `cd` использует переменную окружения `HOME` для перехода в домашнюю директорию пользователя.

Переменные окружения могут быть установлены локально для текущей сессии или глобально для всей системы.

Установка переменных окружения локально:
```bash
HOME=/tmp
``` 

Установка переменных окружения глобально (с использованием `export`):

```bash
export HOME=/tmp
``` 

Глобальное изменение переменных окружения влияет на всю сессию, тогда как локальное изменение действует только для запущенных команд в текущей сессии.

Особенно важной переменной окружения является `PATH`, которая определяет директории, в которых система ищет исполняемые файлы. Изменение `PATH` может повлиять на доступность команд в командной строке.

Для просмотра значения конкретной переменной окружения нужно использовать знак `$` перед переменной
```bash
❯ echo PWD #Пример не правильного использования
PWD
❯ echo $PWD
/home/donqhomo
❯ echo $PYTHONPATH:$(pwd)
:/home/donqhomo
```
## History | история команд 
История команд в командной строке (bash) позволяет легко повторять ранее введенные команды и управлять их выполнением.

1.  **Использование стрелок вверх и вниз**: Когда вы нажимаете клавиши "вверх" и "вниз" на клавиатуре в командной строке, вы перебираете ранее введенные команды. Это позволяет вам быстро повторить или отредактировать команду.
    
2.  **Команда `history`**: Выполнение команды `history` отобразит список ранее введенных команд, каждая снабжена номером. Это удобно для просмотра истории команд и поиска нужных команд.
```bash
history
    1  ls
    2  cd dev
    3  cd ..
    4  ls
    5  cd home
    6  ls
    7  cd donqhomo
    8  ls
    9  cd ..
   10  git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting
   11  plugins=(git zsh-syntax-highlighting)
   12  git clone https://github.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10k
   13  nano ~/.zshrc.

```
    
4.  **Повторный запуск команды по номеру**: Вы можете повторно выполнить команду, указав ее номер, например, `!2` выполнит вторую команду из истории.
    
5.  **Реверсивный поиск с помощью Ctrl + r**: Нажмите комбинацию клавиш Ctrl + r, чтобы запустить обратный поиск по истории. Затем начните вводить символы, и система найдет ближайшую команду, содержащую эти символы. Нажатие Ctrl + r еще раз будет искать следующее соответствие в истории.
    
6.  **Греп в истории**: С помощью команды `history | grep` вы можете выполнять поиск в истории команд по ключевым словам или строкам.
```bash
 history | grep "IP"
   87  docker inspect db | grep IPAddress
  124  docker inspect db | grep IPAddress
```
    
7.  **Изменение размера истории**: Переменная окружения `HISTFILESIZE` определяет максимальное количество команд, которые будут храниться в истории. Вы можете настроить это значение в своем файле `.bashrc` или `.bash_profile`, чтобы управлять размером истории.
    
8.  **Очистка истории**: Для удаления всей истории команд можно выполнить `history -c`.

## Пользователи и группы

**Пользователи (Users)**:
![enter image description here](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImU5OWFjMzQwMDFiMzM4ODk1ZmM1MDFhYjVmYzYxYzAzLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=23a8da8ebe855f4130cfc2a9aff13d653d6e7aead66606541e313aa29ee13d88)

-   **Пользователь (User)**: Это человек или системный процесс, который может выполнять команды и взаимодействовать с файлами и ресурсами в операционной системе. Каждый пользователь имеет уникальное имя, которое служит для идентификации.

 `whoami` - это простая команда, которая выводит имя текущего пользователя, от имени которого вы выполняете команду.

Пример использования `whoami` в Bash:
```bash
$ whoami
donqhomo
```
    
-   **Идентификатор пользователя (UID)**: У каждого пользователя есть уникальный числовой идентификатор, называемый UID. Этот идентификатор связан с именем пользователя и используется системой для определения прав доступа и владения файлами и процессами.
    
-   **Основная группа (Primary Group)**: Каждый пользователь принадлежит к одной основной группе, которая также имеет уникальный идентификатор, называемый GID (Group ID). Основная группа определяется при создании пользователя и используется для управления правами доступа к файлам, созданным этим пользователем.
    
-   **Дополнительные группы (Supplementary Groups)**: Пользователь также может быть членом одной или нескольких дополнительных групп. Эти группы предоставляют пользователю дополнительные права доступа к ресурсам, разрешенным для этих групп.
    

**Группы (Groups)**:
![enter image description here](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjljNTk5ZWNlYzVmMWI5ZTU0ZGU4MzlmNjZmZTMyNzZlLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=5d96a3c8d68076de0e6543b60710297ccb2f168a8d89bca117dc1774145e23d7)

-   **Группа (Group)**: Группа представляет собой коллекцию пользователей, которым предоставлен общий доступ к ресурсам в системе, таким как файлы. Она облегчает управление правами доступа, поскольку разрешения могут быть назначены для всей группы, а не для каждого пользователя отдельно.
    
-   **Идентификатор группы (GID)**: Каждая группа имеет уникальный числовой идентификатор, называемый GID. Этот идентификатор используется для идентификации группы и применения разрешений доступа.
    

**Суперпользователь (root)**:

-   **Суперпользователь (root)**: Это специальный пользователь с UID 0, который обладает полным контролем над системой. Root-пользователь имеет абсолютные права доступа и может выполнять привилегированные операции, такие как изменение конфигурации системы и доступ ко всем файлам и директориям.

**Файл /etc/passwd**:

-   Файл `/etc/passwd` содержит информацию о пользователях в системе. Эта информация включает в себя имена пользователей, их UID и GID, домашние директории и командные оболочки по умолчанию. Файл `/etc/passwd` используется системой для аутентификации пользователей и управления учетными записями.

**Права доступа к файлам и директориям**:

-   Каждый файл и директория в системе имеет свои права доступа, которые определяют, какие операции разрешены для владельца, членов группы и других пользователей. Эти права включают в себя чтение, запись и выполнение файлов, и они могут быть установлены и изменены собственником файла или администратором системы.

 **Команда `id`**:
  `id` - это команда, которая выводит информацию о текущем пользователе, включая UID (идентификатор пользователя), GID (идентификатор основной группы), и список дополнительных групп, к которым пользователь принадлежит.
```bash
❯ id
uid=1000(donqhomo) gid=1000(donqhomo) groups=1000(donqhomo),90(network),98(power),960(docker),984(users),987(storage),991(lp),994(input),996(audio),998(wheel)
```
-   `uid=1000(donqhomo)` - UID пользователя 1000 с именем `donqhomo`.
-   `gid=1000(donqhomo)` - GID основной группы с таким же именем.
-   `groups=1000(donqhomo)` - список дополнительных групп, к которым пользователь `donqhomo` принадлежит.
- `90(network),98(power),960(docker),984(users),987(storage),991(lp),994(input),996(audio),998(wheel)` - системные группы 

## Sudo
В работе с командной строкой мы часто сталкиваемся с ситуациями, в которых необходимо повышать привилегии и выполнять команды от имени суперпользователя root.

-   Установка новых программ
-   Навигация по чужим директориям
-   Изменение прав доступа
-   Изменение содержимого в файлах, не принадлежащих текущему пользователю
-   Создание, редактирование и удаление файлов, когда не хватает прав текущего пользователя
-   Запуск программ, требующих повышенных привилегий

Для получения привелегий super user зайдите в систему и воспользуйтесь утилитой `su` (сокращение от substitute user или switch user). Когда-то такой способ был основным, но сейчас он устарел и не рекомендуется к использованию. 

Основной способ повышать привилегии в современных системах — утилита `sudo` (substitute user and do — дословно «подменить пользователя и выполнить»).

Использовать `sudo` очень просто, достаточно написать эту команду слева от любой другой и выполнить. По умолчанию она пытается повысить привилегии до суперпользователя:
```bash
# Нет прав на выполнение
touch /etc/myfile

touch: cannot touch '/etc/myfile': Permission denied

# С `sudo` все работает
sudo touch /etc/myfile

# Видно, что владелец файла — это суперпользователь `root`
stat /etc/myfile

  File: '/etc/myfile'
  Size: 0           Blocks: 0          IO Block: 4096   regular empty file
Device: ca01h/51713d    Inode: 2761        Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)

# Нет прав на удаление
rm /etc/myfile

rm: remove write-protected regular empty file '/etc/myfile'? y
rm: cannot remove '/etc/myfile': Permission denied

# Опять помогла утилита `sudo`
sudo rm /etc/myfile
``` 

В зависимости от настроек, утилита `sudo` попросит ваш пароль для входа или вообще откажется работать, сказав, что у вас нет права ее использовать. Как правило, Linux для  `sudo` спрашивает пароль и запоминает его на пять минут. На протяжении этого времени вы можете использовать `sudo`, не вводя пароль каждый раз.

Иногда нужно выполнить команду из-под пользователя, отличного от `root`. Тогда придется добавить флаг `-u`:

```bash
sudo -u nobody mkdir /tmp/test
# Директория создана от имени пользователя nobody
stat /tmp/test

  File: '/tmp/test'
  Size: 4096        Blocks: 8          IO Block: 4096   directory
Device: ca01h/51713d    Inode: 4577        Links: 2
Access: (0755/drwxr-xr-x)  Uid: (65534/  nobody)   Gid: (65534/ nogroup)
``` 

Если нужно произвести сразу пачку действий от имени другого пользователя, можно запустить новую оболочку внутри текущей. Другими словами, мы стартуем новую сессию:

```bash
# Команда `sudo` запросит пароль текущего пользователя
sudo -i

# Проверяем, что сессия запущена от суперпользователя
id

uid=0(root) gid=0(root) groups=0(root)
```

## Права доступа
Права доступа к файлам и директориям в командной строке играют важную роль. Они определяют, какие действия разрешены для разных пользователей в отношении файлов и директорий.

Каждый файл и директория в системе Linux имеют ассоциированные с ними права доступа, которые определяют, что можно сделать с этими файлами или директориями. Права доступа представлены следующими символами:

-   **r** (read) - чтение (возможность просматривать содержимое файла или директории).
-   **w** (write) - запись (возможность создавать, изменять и удалять файлы или директории).
-   **x** (execute) - выполнение (возможность запускать исполняемые файлы или переходить в директории).

Права доступа могут быть установлены для трех типов пользователей:

1.  **Владелец** (User) - пользователь, который создал файл или директорию.
2.  **Группа** (Group) - группа, к которой принадлежит владелец файла или директории.
3.  **Остальные** (Other) - все остальные пользователи в системе, не являющиеся владельцем и не входящие в группу.

Для указания прав доступа используются следующие обозначения:

-   **r** - чтение (read).
-   **w** - запись (write).
-   **x** - выполнение (execute).
-   **-** - отсутствие права.

Пример записи прав доступа в виде строки: `-rw-r--r--`.

Теперь разберем пример:
```bash
-rw-r--r-- 1 donqhomo donqhomo 3771 Oct 5  2023 .bashrc
``` 
![enter image description here](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6Ijg3MGY1Yjg4YzBmMWU4ZjllZjE5NTkxZWMzZDRmYTBhLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=47bc381372e785182533695d41beb834b2f6cac4fb4551862dc84a71fdc76172)

Эта строка представляет собой описание прав доступа для файла `.bashrc`. Разделим ее на части:

1.  `-` - этот символ обозначает, что перед нами файл (если бы это была директория, вместо `-` стояла бы `d`).
2.  `rw-` - права первого типа (для владельца файла). Владелец может читать этот файл (r) и писать в него (w). Прочерк в конце означает, что этот файл нельзя исполнять.
3.  `r--` - права второго типа (для группы владельца). В данном случае такие права есть у пользователей, входящих в группу `donqhomo`. Запись `r--` говорит о наличии доступа только для чтения, а изменение и исполнение запрещены.
4.  `r--` - права третьей группы (для всех остальных). Права для остальных пользователей также ограничиваются только чтением.

Кто может удалить этот файл? Для ответа на этот вопрос важно знать права той директории, в которой находится файл `.bashrc`. Потому что права всегда берутся из директории, в которой находится файл. Если у вас есть права записи в эту директорию, вы можете удалить файл. Если нет, то удалить его нельзя.

Что такое `x` в отношении директорий? Право выполнения (`x`) для директории позволяет вам входить в нее и просматривать ее содержимое. Если убрать это право (`-x`), вы не сможете войти в директорию, даже если у вас есть права на чтение ее содержимого. Таким образом, право `x` для директории позволяет вам просматривать ее содержимое и выполнять действия с файлами внутри нее.

Что касается числового представления прав доступа, то оно используется в виде трех чисел, представляющих группы rwx для каждого из типов пользователей (владелец, группа, остальные). Каждая из этих групп rwx может быть представлена в виде бинарного числа от 0 до 7:

-   **0** - нет прав (---).
-   **1** - выполнение (--x).
-   **2** - запись (-w-).
-   **3** - запись и выполнение (-wx).
-   **4** - чтение (r--).
-   **5** - чтение и выполнение (r-x).
-   **6** - чтение и запись (rw-).
-   **7** - чтение, запись и выполнение (rwx).

Примеры числового представления прав доступа:

-   `755` соответствует `-rwxr-xr-x`.
-   `644` соответствует `-rw-r--r--`.

Чтобы изменить владельца файла или директории, вы можете использовать команду `chown`, а для изменения прав доступа - команду `chmod`. Команда `chmod` позволяет вам установить нужные права доступа для файла или директории. Например:
```bash
chmod +r file.txt   # Добавить право чтения к файлу.
chmod 754 file.txt  # Установить права доступа в виде числа.
```
